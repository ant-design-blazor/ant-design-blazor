using System;
using System.ComponentModel;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.JSInterop;

namespace AntDesign
{
    public abstract class BcdForm : ComponentBase, IDisposable
    {
        protected IJSRuntime JsRuntime => BcdFormContainer.BcdFormContainerInstance?.BcdJsRuntime;

        public const string Prefix = "bcd-form";

        protected BcdForm()
        {
            InitComponent();
        }

        protected BcdForm(string name) : this()
        {
            if (!string.IsNullOrWhiteSpace(name))
            {
                this.Name = name;
            }
        }

        #region form properties

        /// <summary>
        /// Indicates whether it needs to be re rendered
        /// </summary>
        internal bool ShouldReRender { get; set; } = true;

        /// <summary>
        /// all public property should be proxy to BcdFormOptions
        /// </summary>
        internal BcdFormOptions Options { get; set; } = new BcdFormOptions();

        /// <summary>
        /// The width of the form, in pixels
        /// </summary>
        public int Width
        {
            get => Options.Width;
            set
            {
                Options.Width = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Where the form is minimized
        /// </summary>
        public MinPosition MinPosition
        {
            get => Options.MinPosition;
            set
            {
                Options.MinPosition = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// form body's style
        /// </summary>
        public string BodyStyle
        {
            get => Options.BodyStyle;
            set
            {
                Options.BodyStyle = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Remove from DOM when closing. Default is true.
        /// If <c>DestroyOnClose = false</c>, be sure to use a global variable to accept the instance of BcdForm
        /// </summary>
        public bool DestroyOnClose
        {
            get => Options.DestroyOnClose;
            set
            {
                Options.DestroyOnClose = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Unique identification, it will be used as the Id attribute of the form root DOM. If it is not defined, it will be generated by default
        /// </summary>
        public string Name
        {
            get => Options.Name;
            set
            {
                Options.Name = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow header to be displayed. Default is true
        /// </summary>
        public bool EnableHeader
        {
            get => Options.EnableHeader;
            set
            {
                Options.EnableHeader = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow Mask to be displayed. Default is false
        /// </summary>
        public bool ShowMask
        {
            get => Options.ShowMask;
            set
            {
                Options.ShowMask = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Whether to close the form when the mask is clicked, if ShowMask is true.
        /// </summary>
        public bool MaskClosable
        {
            get => Options.MaskClosable;
            set
            {
                Options.MaskClosable = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// the style of Mask, if <paramref name="ShowMask"/> is true.
        /// </summary>
        public string MaskStyle
        {
            get => Options.MaskStyle;
            set
            {
                Options.MaskStyle = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// the title of form. Default value is BcdForm
        /// </summary>
        public string Title
        {
            get => Options.Title;
            set
            {
                Options.Title = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow minimization
        /// </summary>
        public bool MinimizeBox
        {
            get => Options.MinimizeBox;
            set
            {
                Options.MinimizeBox = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow maximum
        /// </summary>
        public bool MaximizeBox
        {
            get => Options.MaximizeBox;
            set
            {
                Options.MaximizeBox = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow drag
        /// </summary>
        public bool Draggable
        {
            get => Options.Draggable;
            set
            {
                Options.Draggable = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Drag is only allowed in the viewport, if Draggable is true.
        /// </summary>
        public bool DragInViewport
        {
            get => Options.DragInViewport;
            set
            {
                Options.DragInViewport = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Whether the form is visible or not
        /// </summary>
        public bool Visible { get; private set; }

        /// <summary>
        /// Whether the form has been removed from DOM
        /// </summary>
        public bool HasDestroyed { get; private set; } = true;

        /// <summary>
        /// The form's state: maximize, minimize or normalize
        /// </summary>
        public FormState FormState
        {
            get => _formState;
            private set
            {
                LastState = _formState;
                _formState = value;
                ShouldReRender = true;
            }
        }

        #endregion

        protected virtual void InitComponent()
        {

        }

        internal string GetHeaderCls()
        {
            return Draggable ? "draggable" : "";
        }

        internal string GetStyle()
        {
            return Visible ? "" : "display:none;";
        }

        internal string GetFormStyle()
        {
            if (_firstRender)
            {
                var sty = $"width: {Width}px;";
                _lastNormal = sty;
            }

            return _lastNormal;
        }

        private string _lastNormal;
        private bool _firstRender = true;

        #region Show

        /// <summary>
        /// Trigger before displaying form. The display can be cancelled by CancelEventArgs.
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnShowingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Show form
        /// </summary>
        /// <returns></returns>
        public async Task ShowAsync()
        {
            CancelEventArgs eventArgs = new CancelEventArgs(false);
            await OnShowingAsync(eventArgs);
            if (eventArgs.Cancel)
            {
                return;
            }

            if (!Visible)
            {
                Visible = true;
                if (HasDestroyed)
                {
                    HasDestroyed = false;
                    await BcdFormContainer.BcdFormContainerInstance.AppendFormAsync(this);
                }
                await InvokeStateHasChangedAsync();
            }
        }

        #endregion

        #region close

        /// <summary>
        /// Trigger before closing form. The close can be cancelled by CancelEventArgs
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnClosingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Trigger before the form destroying (removing) from DOM. The destroy Can be cancelled by CancelEventArgs
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnDestroyingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }


        /// <summary>
        /// Close form.
        /// <para>
        ///     If you want to call the <b>base.CloseAsync</b> in the component, be sure to use <b>pure event handlers</b>! Just like:
        ///     <code>
        ///         @onclick="EventUtil.AsNonRenderingEventHandler(async => { await base.CloseAsync(); })"
        ///     </code>
        /// </para>
        /// <para>
        ///     It's in <b>EventUtil</b> class and is provided by SteveSandersonMs
        /// </para>
        /// </summary>
        /// <returns></returns>
        public async Task CloseAsync()
        {
            CancelEventArgs eventArgs = new CancelEventArgs(false);
            await OnClosingAsync(eventArgs);

            if (eventArgs.Cancel)
            {
                return;
            }

            if (Visible)
            {
                Visible = false;
                await InvokeStateHasChangedAsync();

                if (DestroyOnClose && !HasDestroyed)
                {
                    HasDestroyed = true;
                    eventArgs = new CancelEventArgs(false);
                    await OnDestroyingAsync(eventArgs);

                    if (eventArgs.Cancel)
                    {
                        return;
                    }
                    await BcdFormContainer.BcdFormContainerInstance.RemoveFormAsync(this);

                    //await InvokeStateHasChangedAsync();
                }
            }
        }

        #endregion

        #region min max

        /// <summary>
        /// last form state
        /// </summary>
        private FormState LastState { get; set; }

        private FormState _formState;

        internal string GetFormState()
        {
            return IsMin()
                ? $"{FormState.ToCls()} {MinPosition.ToCls()}"
                : FormState.ToCls();
        }

        /// <summary>
        /// Minimize form
        /// </summary>
        public void Min()
        {
            if (!IsMin())
            {
                FormState = FormState.Min;
                BcdFormContainer.MinFormCount += 1;
            }
        }

        /// <summary>
        /// Maximize form
        /// </summary>
        public void Max()
        {
            if (!IsMax())
            {
                if (IsMin())
                {
                    BcdFormContainer.MinFormCount -= 1;
                }

                FormState = FormState.Max;
            }
        }

        /// <summary>
        /// Restore form
        /// </summary>
        public void Restore()
        {
            if (!IsNormal())
            {
                if (IsMin())
                {
                    BcdFormContainer.MinFormCount -= 1;
                }

                FormState = FormState.Normal;
            }
        }

        /// <summary>
        /// Trigger Max or Restore
        /// </summary>
        internal void TriggerMaxBox()
        {
            if (IsMax())
            {
                Restore();
            }
            else if (IsMin())
            {
                if (LastState.IsNormal())
                {
                    Restore();
                }
                else
                {
                    Max();
                }
            }
            else
            {
                Max();
            }
        }

        /// <summary>
        /// Determine whether the form is minimized
        /// </summary>
        /// <returns></returns>
        public bool IsMin()
        {
            return FormState.IsMin();
        }

        /// <summary>
        /// Determine whether the form is maximized
        /// </summary>
        /// <returns></returns>
        public bool IsMax()
        {
            return FormState.IsMax();
        }

        /// <summary>
        /// Determine whether the form is normalized
        /// </summary>
        /// <returns></returns>
        public bool IsNormal()
        {
            return FormState.IsNormal();
        }

        #endregion

        #region Adapter or proxy

        /// <summary>
        /// jsRuntime.InvokeVoidAsync adapter
        /// </summary>
        /// <param name="func"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected async Task JsInvokeVoidAsync(string func, params object[] args)
        {
            if (JsRuntime != null)
            {
                await JsRuntime.InvokeVoidAsync(func, args);
            }
            else
            {
                throw new Exception("cannot access IJsRuntime to invoke js");
            }
        }

        /// <summary>
        /// jsRuntime.InvokeAsync adapter
        /// </summary>
        /// <param name="func"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected async ValueTask<T> JsInvokeAsync<T>(string func, params object[] args)
        {
            if (JsRuntime != null)
            {
                return await JsRuntime.InvokeAsync<T>(func, args);
            }
            else
            {
                throw new Exception("cannot access IJsRuntime to invoke js");
            }
        }

        /// <summary>
        /// this hides StateHasChanged in ComponentBase,
        /// and it is implemented internally through <c>InvokeStateHasChanged</c> method
        /// </summary>
        protected new void StateHasChanged()
        {
            InvokeStateHasChanged();
        }

        /// <summary>
        /// StateHasChanged adapter
        /// </summary>
        protected void InvokeStateHasChanged()
        {
            ShouldReRender = true;
            BcdFormContainer.BcdFormContainerInstance.InvokeStateHasChanged();
        }

        /// <summary>
        /// InvokeAsync(StateHasChanged) adapter
        /// </summary>
        /// <returns></returns>
        protected Task InvokeStateHasChangedAsync()
        {
            ShouldReRender = true;
            return BcdFormContainer.BcdFormContainerInstance.InvokeStateHasChangedAsync();
        }

        #endregion

        #region dispose

        /// <summary>
        /// Has the object been released
        /// </summary>
        protected bool IsDisposed { get; private set; }

        /// <summary>
        /// If rewriting, be sure to base.Dispose Call this function
        /// </summary>
        /// <param name="disposing"></param>
        protected virtual void Dispose(bool disposing)
        {
            if (!IsDisposed)
            {
                if (disposing)
                {
                    // destroy DOM from the Document
                    _ = BcdFormContainer.BcdFormContainerInstance.RemoveFormAsync(this);
                }
            }
            IsDisposed = true;
        }

        /// <summary>
        /// dispose the form
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~BcdForm()
        {
            // Finalizer calls Dispose(false)
            Dispose(false);
        }

        #endregion

        internal async Task AfterRenderAsync()
        {
            if (_firstRender && Draggable)
            {
                await JsInvokeVoidAsync(JSInteropConstants.EnableDraggable,
                    $"#{Name} .bcd-form-header .bcd-form-title", $"#{Name} .bcd-form", DragInViewport);
            }

            if (IsMin())
            {
                var lastNormal = await JsInvokeAsync<string>(JSInteropConstants.MinResetStyle, $"#{Name}", LastState.IsNormal());
                if (LastState.IsNormal())
                {
                    _lastNormal = lastNormal;
                }
            }
            else if (IsMax())
            {
                var lastNormal = await JsInvokeAsync<string>(JSInteropConstants.MaxResetStyle, $"#{Name}", LastState.IsNormal());
                if (LastState.IsNormal())
                {
                    _lastNormal = lastNormal;
                }
            }


            // ReSharper disable once MethodHasAsyncOverload
            AfterBcdRender(_firstRender);
            await AfterBcdRenderAsync(_firstRender);
            if (_firstRender)
            {
                _firstRender = false;
            }

            ShouldReRender = false;
        }

        /// <summary>
        /// it will trigger in OnAfterRenderAsync
        /// </summary>
        /// <param name="firstRender">Is the form rendered for the first time</param>
        protected virtual void AfterBcdRender(bool firstRender)
        {
        }
        /// <summary>
        /// it will trigger in OnAfterRenderAsync
        /// </summary>
        /// <param name="firstRender">Is the form rendered for the first time</param>
        protected virtual Task AfterBcdRenderAsync(bool firstRender)
        {
            return Task.CompletedTask;
        }
    }
}
